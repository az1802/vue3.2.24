"use strict";
exports.__esModule = true;
exports.stringifyStatic = void 0;
/**
 * This module is Node-only.
 */
var compiler_core_1 = require("@vue/compiler-core");
var shared_1 = require("@vue/shared");
/**
 * Regex for replacing placeholders for embedded constant variables
 * (e.g. import URL string constants generated by compiler-sfc)
 */
var expReplaceRE = /__VUE_EXP_START__(.*?)__VUE_EXP_END__/g;
/**
 * Turn eligible hoisted static trees into stringified static nodes, e.g.
 *
 * ```js
 * const _hoisted_1 = createStaticVNode(`<div class="foo">bar</div>`)
 * ```
 *
 * A single static vnode can contain stringified content for **multiple**
 * consecutive nodes (element and plain text), called a "chunk".
 * `@vue/runtime-dom` will create the content via innerHTML in a hidden
 * container element and insert all the nodes in place. The call must also
 * provide the number of nodes contained in the chunk so that during hydration
 * we can know how many nodes the static vnode should adopt.
 *
 * The optimization scans a children list that contains hoisted nodes, and
 * tries to find the largest chunk of consecutive hoisted nodes before running
 * into a non-hoisted node or the end of the list. A chunk is then converted
 * into a single static vnode and replaces the hoisted expression of the first
 * node in the chunk. Other nodes in the chunk are considered "merged" and
 * therefore removed from both the hoist list and the children array.
 *
 * This optimization is only performed in Node.js.
 */
var stringifyStatic = function (children, context, parent) {
    // bail stringification for slot content
    if (context.scopes.vSlot > 0) {
        return;
    }
    var nc = 0; // current node count
    var ec = 0; // current element with binding count
    var currentChunk = [];
    var stringifyCurrentChunk = function (currentIndex) {
        if (nc >= 20 /* StringifyThresholds.NODE_COUNT */ ||
            ec >= 5 /* StringifyThresholds.ELEMENT_WITH_BINDING_COUNT */) {
            // combine all currently eligible nodes into a single static vnode call
            var staticCall = (0, compiler_core_1.createCallExpression)(context.helper(compiler_core_1.CREATE_STATIC), [
                JSON.stringify(currentChunk.map(function (node) { return stringifyNode(node, context); }).join('')).replace(expReplaceRE, "\" + $1 + \""),
                // the 2nd argument indicates the number of DOM nodes this static vnode
                // will insert / hydrate
                String(currentChunk.length)
            ]);
            // replace the first node's hoisted expression with the static vnode call
            replaceHoist(currentChunk[0], staticCall, context);
            if (currentChunk.length > 1) {
                for (var i_1 = 1; i_1 < currentChunk.length; i_1++) {
                    // for the merged nodes, set their hoisted expression to null
                    replaceHoist(currentChunk[i_1], null, context);
                }
                // also remove merged nodes from children
                var deleteCount = currentChunk.length - 1;
                children.splice(currentIndex - currentChunk.length + 1, deleteCount);
                return deleteCount;
            }
        }
        return 0;
    };
    var i = 0;
    for (; i < children.length; i++) {
        var child = children[i];
        var hoisted = getHoistedNode(child);
        if (hoisted) {
            // presence of hoisted means child must be a stringifiable node
            var node = child;
            var result = analyzeNode(node);
            if (result) {
                // node is stringifiable, record state
                nc += result[0];
                ec += result[1];
                currentChunk.push(node);
                continue;
            }
        }
        // we only reach here if we ran into a node that is not stringifiable
        // check if currently analyzed nodes meet criteria for stringification.
        // adjust iteration index
        i -= stringifyCurrentChunk(i);
        // reset state
        nc = 0;
        ec = 0;
        currentChunk.length = 0;
    }
    // in case the last node was also stringifiable
    stringifyCurrentChunk(i);
};
exports.stringifyStatic = stringifyStatic;
var getHoistedNode = function (node) {
    return ((node.type === compiler_core_1.NodeTypes.ELEMENT && node.tagType === compiler_core_1.ElementTypes.ELEMENT) ||
        node.type == compiler_core_1.NodeTypes.TEXT_CALL) &&
        node.codegenNode &&
        node.codegenNode.type === compiler_core_1.NodeTypes.SIMPLE_EXPRESSION &&
        node.codegenNode.hoisted;
};
var dataAriaRE = /^(data|aria)-/;
var isStringifiableAttr = function (name, ns) {
    return ((ns === parserOptions_1.DOMNamespaces.HTML
        ? (0, shared_1.isKnownHtmlAttr)(name)
        : ns === parserOptions_1.DOMNamespaces.SVG
            ? (0, shared_1.isKnownSvgAttr)(name)
            : false) || dataAriaRE.test(name));
};
var replaceHoist = function (node, replacement, context) {
    var hoistToReplace = node.codegenNode.hoisted;
    context.hoists[context.hoists.indexOf(hoistToReplace)] = replacement;
};
var isNonStringifiable = /*#__PURE__*/ (0, shared_1.makeMap)("caption,thead,tr,th,tbody,td,tfoot,colgroup,col");
/**
 * for a hoisted node, analyze it and return:
 * - false: bailed (contains non-stringifiable props or runtime constant)
 * - [nc, ec] where
 *   - nc is the number of nodes inside
 *   - ec is the number of element with bindings inside
 */
function analyzeNode(node) {
    if (node.type === compiler_core_1.NodeTypes.ELEMENT && isNonStringifiable(node.tag)) {
        return false;
    }
    if (node.type === compiler_core_1.NodeTypes.TEXT_CALL) {
        return [1, 0];
    }
    var nc = 1; // node count
    var ec = node.props.length > 0 ? 1 : 0; // element w/ binding count
    var bailed = false;
    var bail = function () {
        bailed = true;
        return false;
    };
    // TODO: check for cases where using innerHTML will result in different
    // output compared to imperative node insertions.
    // probably only need to check for most common case
    // i.e. non-phrasing-content tags inside `<p>`
    function walk(node) {
        for (var i = 0; i < node.props.length; i++) {
            var p = node.props[i];
            // bail on non-attr bindings
            if (p.type === compiler_core_1.NodeTypes.ATTRIBUTE &&
                !isStringifiableAttr(p.name, node.ns)) {
                return bail();
            }
            if (p.type === compiler_core_1.NodeTypes.DIRECTIVE && p.name === 'bind') {
                // bail on non-attr bindings
                if (p.arg &&
                    (p.arg.type === compiler_core_1.NodeTypes.COMPOUND_EXPRESSION ||
                        (p.arg.isStatic && !isStringifiableAttr(p.arg.content, node.ns)))) {
                    return bail();
                }
                if (p.exp &&
                    (p.exp.type === compiler_core_1.NodeTypes.COMPOUND_EXPRESSION ||
                        p.exp.constType < compiler_core_1.ConstantTypes.CAN_STRINGIFY)) {
                    return bail();
                }
            }
        }
        for (var i = 0; i < node.children.length; i++) {
            nc++;
            var child = node.children[i];
            if (child.type === compiler_core_1.NodeTypes.ELEMENT) {
                if (child.props.length > 0) {
                    ec++;
                }
                walk(child);
                if (bailed) {
                    return false;
                }
            }
        }
        return true;
    }
    return walk(node) ? [nc, ec] : false;
}
function stringifyNode(node, context) {
    if ((0, shared_1.isString)(node)) {
        return node;
    }
    if ((0, shared_1.isSymbol)(node)) {
        return "";
    }
    switch (node.type) {
        case compiler_core_1.NodeTypes.ELEMENT:
            return stringifyElement(node, context);
        case compiler_core_1.NodeTypes.TEXT:
            return (0, shared_1.escapeHtml)(node.content);
        case compiler_core_1.NodeTypes.COMMENT:
            return "<!--".concat((0, shared_1.escapeHtml)(node.content), "-->");
        case compiler_core_1.NodeTypes.INTERPOLATION:
            return (0, shared_1.escapeHtml)((0, shared_1.toDisplayString)(evaluateConstant(node.content)));
        case compiler_core_1.NodeTypes.COMPOUND_EXPRESSION:
            return (0, shared_1.escapeHtml)(evaluateConstant(node));
        case compiler_core_1.NodeTypes.TEXT_CALL:
            return stringifyNode(node.content, context);
        default:
            // static trees will not contain if/for nodes
            return '';
    }
}
function stringifyElement(node, context) {
    var res = "<".concat(node.tag);
    var innerHTML = '';
    for (var i = 0; i < node.props.length; i++) {
        var p = node.props[i];
        if (p.type === compiler_core_1.NodeTypes.ATTRIBUTE) {
            res += " ".concat(p.name);
            if (p.value) {
                res += "=\"".concat((0, shared_1.escapeHtml)(p.value.content), "\"");
            }
        }
        else if (p.type === compiler_core_1.NodeTypes.DIRECTIVE) {
            if (p.name === 'bind') {
                var exp = p.exp;
                if (exp.content[0] === '_') {
                    // internally generated string constant references
                    // e.g. imported URL strings via compiler-sfc transformAssetUrl plugin
                    res += " ".concat(p.arg.content, "=\"__VUE_EXP_START__").concat(exp.content, "__VUE_EXP_END__\"");
                    continue;
                }
                // constant v-bind, e.g. :foo="1"
                var evaluated = evaluateConstant(exp);
                if (evaluated != null) {
                    var arg = p.arg && p.arg.content;
                    if (arg === 'class') {
                        evaluated = (0, shared_1.normalizeClass)(evaluated);
                    }
                    else if (arg === 'style') {
                        evaluated = (0, shared_1.stringifyStyle)((0, shared_1.normalizeStyle)(evaluated));
                    }
                    res += " ".concat(p.arg.content, "=\"").concat((0, shared_1.escapeHtml)(evaluated), "\"");
                }
            }
            else if (p.name === 'html') {
                // #5439 v-html with constant value
                // not sure why would anyone do this but it can happen
                innerHTML = evaluateConstant(p.exp);
            }
            else if (p.name === 'text') {
                innerHTML = (0, shared_1.escapeHtml)((0, shared_1.toDisplayString)(evaluateConstant(p.exp)));
            }
        }
    }
    if (context.scopeId) {
        res += " ".concat(context.scopeId);
    }
    res += ">";
    if (innerHTML) {
        res += innerHTML;
    }
    else {
        for (var i = 0; i < node.children.length; i++) {
            res += stringifyNode(node.children[i], context);
        }
    }
    if (!(0, shared_1.isVoidTag)(node.tag)) {
        res += "</".concat(node.tag, ">");
    }
    return res;
}
// __UNSAFE__
// Reason: eval.
// It's technically safe to eval because only constant expressions are possible
// here, e.g. `{{ 1 }}` or `{{ 'foo' }}`
// in addition, constant exps bail on presence of parens so you can't even
// run JSFuck in here. But we mark it unsafe for security review purposes.
// (see compiler-core/src/transforms/transformExpression)
function evaluateConstant(exp) {
    if (exp.type === compiler_core_1.NodeTypes.SIMPLE_EXPRESSION) {
        return new Function("return ".concat(exp.content))();
    }
    else {
        // compound
        var res_1 = "";
        exp.children.forEach(function (c) {
            if ((0, shared_1.isString)(c) || (0, shared_1.isSymbol)(c)) {
                return;
            }
            if (c.type === compiler_core_1.NodeTypes.TEXT) {
                res_1 += c.content;
            }
            else if (c.type === compiler_core_1.NodeTypes.INTERPOLATION) {
                res_1 += (0, shared_1.toDisplayString)(evaluateConstant(c.content));
            }
            else {
                res_1 += evaluateConstant(c);
            }
        });
        return res_1;
    }
}
